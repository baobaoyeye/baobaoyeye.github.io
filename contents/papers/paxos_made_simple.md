---
layout: post
---

简介
===

Paxos算法用来实现一个故障容忍的分布式系统，一直被认为是难懂的，可能是因为原来的描述对于读者来说太greek了。事实上它是很多常见算法分布式算法中最简单的啦。它的核心是个一致算法——之前论文中说到的集会算法。下一章会描述为了保证这个算法安全性而必须的一些属性。最后一章会描述完整的Paxos算法。


一致性算法
========

问题
----
假设一个进程的集合能够提出值。一个一致性算法保证所有提出的值中只有一个会被选中。如果没有值被提出，那也不能有值被选中。如果一个值能够被选中，那么进程们可以习得这个值。一致性的安全需求如下：
* 一个被提议的值可能被选中，
* 只有一个值可以被选中，并且
* 除非一个值真的被选中了，没有进程可以学习到它。

我们不会尝试明确的指定活跃度的需求。尽管，目标是保证一些提出的值最终被选中并且，如果一个值被选中了，那么一个进程能够最终习得这个值。

我们用三类代理：proposer, acceptor, learner。担当一致性算法中的三个规则。在一个实现中，一个进程可能会担当多于一个的代理角色。但是从代理到进程的映射关系我们这里不考虑

**一些前提假设**
假设代理之间能够通过发消息通信，我们使用常见的异步、非拜占庭模式，
* 代理可能以任何速度操作，可能因为停止个失败，可能重启。因为在一个值被选出之后可能所有的代理都失败，然后重启。除非有些信息被一个失败又重启的代理记住，否则将没有任何解决方案。
* 消息被投递出去可以花费任意长的时间，能够重复，能够丢，但是不能够出错。

选一个值
-------
选一个值最简单的方法是只有一个acceptor代理。一个proposer发起一个提案给acceptor，这个acceptor选择它接收到的第一个提出的值。尽管简单，但是这个方案是不令人满意的，因为acceptor的失败将导致后续的推进是不可能完成的。

因此让我们尝试别的方法去选一个值，我们用多个acceptor代理代替一个单独的acceptor。一个proposer发起一个提案值给一个acceptor集合。一个acceptor可能accept这个提案值，当acceptor集合中的大多数accept了这个值，它才会被选中。因为任何两个大多数都包含一个公共的acceptor，如果一个acceptor只能accept最多一个值，那么这种方法就是work的。
在不存在失败和丢失消息的情况下。在只有一个值被唯一的proposer提出时也能被选中。这就暗示了下面的条件：
**P1. 一个acceptor必须accept它接到的第一提案。**

但是没有这个条件会引出一个问题。一系列的值能够在同一时间被不同的proposer被提出。每一个acceptor都accept一个值，但是没有一个唯一的值被它们中的大多数接受。即使只有两个提案值，如果一个值被一半的acceptor接受，一个单acceptor的失败会导致他不能够习得之前被选中的值。



学习一个已选的值
-------------

推进
----

实现
----


实现一个状态机
============




























# 一致性算法
## 问题
&emsp;&emsp;一个进程集合可以提出很多值，一个一致性算法需要保证只有一个
### 三个规则：
* 一个被提议的值可能被选中，
* 只有一个值可以被选中，并且
* 除非一个值真的被选中了，没有进程可以学习到它。
一致性算法中的这三个规则由三种代理来实际完成：proposers，acceptors，learners。在实现中一个
单进程可能扮演多个角色。
### 代理满足的假设：
* 代理处理的速度完全随意，它可能失败或者停止，或者重启。由于一个值被选中后所有的代理可能失败紧接着重启，
除非代理可以记录某些信息，否则这种场景将无法解决。
* 消息可以被反反复复的传递，可以重复，丢失，但是不能被修改。
## 选择一个值
需要让acceptor集合是由代理中的大多数组成。因为任何两个大多数至少包含一个公共的acceptor，
只有一个acceptor只能够接受一个值，就可以保证只一个一个值被选中是能达成的。
