---
layout: post
---

简介
===

Paxos算法用来实现一个故障容忍的分布式系统，一直被认为是难懂的，可能是因为原来的描述对于读者来说太greek了。事实上它是很多常见算法分布式算法中最简单的啦。它的核心是个一致算法——之前论文中说到的集会算法。下一章会描述为了保证这个算法安全性而必须的一些属性。最后一章会描述完整的Paxos算法。


一致性算法
========

问题
----
假设一个进程的集合能够提出值。一个一致性算法保证所有提出的值中只有一个会被选中。如果没有值被提出，那也不能有值被选中。如果一个值能够被选中，那么进程们可以习得这个值。一致性的安全需求如下：
* 一个被提议的值可能被选中，
* 只有一个值可以被选中，并且
* 除非一个值真的被选中了，没有进程可以学习到它。

我们不会尝试明确的指定活跃度的需求。尽管，目标是保证一些提出的值最终被选中并且，如果一个值被选中了，那么一个进程能够最终习得这个值。

我们用三类代理：proposer, acceptor, learner。担当一致性算法中的三个规则。在一个实现中，一个进程可能会担当多于一个的代理角色。但是从代理到进程的映射关系我们这里不考虑

**一些前提假设**
假设代理之间能够通过发消息通信，我们使用常见的异步、非拜占庭模式，
* 代理可能以任何速度操作，可能因为停止个失败，可能重启。因为在一个值被选出之后可能所有的代理都失败，然后重启。除非有些信息被一个失败又重启的代理记住，否则将没有任何解决方案。
* 消息被投递出去可以花费任意长的时间，能够重复，能够丢，但是不能够出错。

选一个值
-------
选一个值最简单的方法是只有一个acceptor代理。一个proposer发起一个提案给acceptor，这个acceptor选择它接收到的第一个提出的值。尽管简单，但是这个方案是不令人满意的，因为acceptor的失败将导致后续的推进是不可能完成的。

因此让我们尝试别的方法去选一个值，我们用多个acceptor代理代替一个单独的acceptor。一个proposer发起一个提案值给一个acceptor集合。一个acceptor可能accept这个提案值，当acceptor集合中的大多数accept了这个值，它才会被选中。因为任何两个大多数都包含一个公共的acceptor，如果一个acceptor只能accept最多一个值，那么这种方法就是work的。
在不存在失败和丢失消息的情况下。在只有一个值被唯一的proposer提出时也能被选中。这就暗示了下面的**必要条件**：
**P1. 一个acceptor必须accept它接到的第一提议。**

但是没有这个条件会引出一个问题。一系列的值能够在同一时间被不同的proposer被提出。每一个acceptor都accept一个值，但是没有一个唯一的值被它们中的大多数接受。即使只有两个提案值，如果一个值被一半的acceptor接受，一个单acceptor的失败会导致他不能够习得之前被选中的值。

P1和这个必要条件：只有当一个值被大多数acceptors接受这个值才被选中，暗示一个acceptor必须被允许接受多余一个提议。我们持续追踪一个acceptor可能接受的不同提议，每个提议被赋予一个整数号。因此一个提议包含一个提议号和一个值。为了避免混乱，我们需要不同的提议有不同的提议号，这个如何获得满足依赖于实现，因此目前我们只是假设它。一个值被选中当仅有一个带着该值的提议被acceptor中的大多数接受。如果是那样的话，我们说这个提议（就如同它的值）被选中了。

我们可以允许多个提议被选中，但是我们必须保证所有被选中的提议拥有相同的值。通过在提议号上做归纳，它足以保证：

**P2. 如果一个带着v的提议被选中，那么每一个被选中的更高序号的提议都带着值v。**

因为序号是整体有序的，条件P2保证了只有一个值被选中的关键安全属性

为了被选中，一个提议必须被至少一个acceptor接受。因此我们能够通过满足下面的条件来满足P2：

**P2A. 如果一个带着v的提议被选中，那么每一个被任意acceptor接受的更高序号的提议都带着值v。**

我们仍然维护P1来保证某个提议被选中。由于通信是异步的，因此一个提议可以被某个从未接到任何提议的特殊接受者c选中。

假设一个提议者"醒来"并且提出一个序号更高的提议带着一个不同的值，P1需要c接受这个提议，和P2A矛盾。同时保证P1和P2A需要对P2A增强：

**P2B. 如果一个带着v的提议被选中，那么每一个被任意提议者提出的更高序号的提议都带着值v。**

因为一个提议在能够被一个acceptor接受之前它必须被一个提议者提出，P2B隐含P2A，响应的隐含P2。

为了发现如何瞒住P2B，让我们考虑

我们假设某个提议(m,v)被选中，进而证明任何被提出的提议号为n > m.其值为v。我们将通过在n上做归纳使得证明更简单。

因此我们能够证明：提议号n的值是v，
只需证明每一被提出的提议号为x，都带着值v，x ∈ set(m,..,(n-1))
为了让提议号m的提议被选中，必须存在一个集合C，C包含一个大多数接受者，其中的每个接受者都接受了(m,v)

结合这个归纳假设，m被选中的前提暗示了：

每一个在集合C中的接受者接受一个号在m..(n-1)的提议，并且每一个提议带着号m..(n-1)

**P2C. 对于任何v和n，如果一个提议(n,v)被提出，那么存在一个包含接受者中的大多数的集合S，要么是P2C(a),要么是P2C(b)**
**P2C(a) S中没有接受者，接受过任何提议号小于n的提议**
**P2C(b) 所有被S中接受者接受的提议号小于n的提议中提议号最高的提议的值是v**

为了维护P2C的不变性，一个提议者想要提出一个号是n的提议必须先学习号小于n的最大号的提议，如果真的有的话

学习一个已选的值
-------------

推进
----

实现
----


实现一个状态机
============

一个简单的方式实现一个分布式系统是客户端都把命令发给一个中心服务，这个服务能够被描述成一个以某种顺序处理客户端命令的确定状态机。这个状态机有一个当前状态；它做一步通过获取一个输入命令并且产出一个输出和一个新的状态。例如，一个分布式银行系统的客户端可能是提款机，并且这个状态机状态可能包含所有用户的账户余额。一个提款操作会通过执行一个状态机命令完成（当且仅当余额比提款数目大时减少一个账户余额），产生一个包含新老账户余额的输出。

当单中心服务故障了，整体也就故障了。我们因此通过使用一个服务集合来代替中心服务。集合中的服务都单独实现状态机。因为状态机是确定的，只要所有的服务按照相同顺序执行命令，所有的服务会产出相同顺序的状态和输出。一个客户端提出一个命令，然后能够使用任何服务为它生成的输出。

为了确保所有的服务以相同的顺序执行状态机命令，我们实现了一个由彼此分离的Paxos一致性算法实例组成的序列。被第i个实例选中的值作为序列中的第i个状态机命令。每个服务在每个算法实例中扮演所有的角色（proposer，acceptor，learner）。目前为止，我假设这个服务的集合是固定的，因此所有的一致性算法的实例使用相同的代理集合。

在一个正常的操作中，一个单独的服务会被选中做leader，在所有一致性算法实例中担任proposer（唯一的尝试提交提议）。客户端发送命令给leader，它决定一系列命令的顺序。如果一个leader决定一个确定的客户端命令应该是第135号命令，它会尝试选择第135号一致性算法实例选出的值作为命令。通常是成功的。可能因为故障而失败，或因为别服务认为它自己是leader并且对于第135号命令是什么有不同的观点。但是这个一致性算法保证在135号位置最多一个命令能够被选择。

























# 一致性算法
## 问题
&emsp;&emsp;一个进程集合可以提出很多值，一个一致性算法需要保证只有一个
### 三个规则：
* 一个被提议的值可能被选中，
* 只有一个值可以被选中，并且
* 除非一个值真的被选中了，没有进程可以学习到它。
一致性算法中的这三个规则由三种代理来实际完成：proposers，acceptors，learners。在实现中一个
单进程可能扮演多个角色。
### 代理满足的假设：
* 代理处理的速度完全随意，它可能失败或者停止，或者重启。由于一个值被选中后所有的代理可能失败紧接着重启，
除非代理可以记录某些信息，否则这种场景将无法解决。
* 消息可以被反反复复的传递，可以重复，丢失，但是不能被修改。
## 选择一个值
需要让acceptor集合是由代理中的大多数组成。因为任何两个大多数至少包含一个公共的acceptor，
只有一个acceptor只能够接受一个值，就可以保证只一个一个值被选中是能达成的。
