问号表达式在glibc中的怪异用法：

```
// 怪异的问号表达式
C = A ?: B;

// 人能看的解释
if (A) {
    C = A;
} else {
    C = B;
}
```

在c/c++中用汇编指令的写法
__asm(code [: output_operand_list [: input_operand_list [: clobbered_register_list]]])

真实的案例
__asm ("" : "=r" (__atg100_val) : "0" (*(mem)));	

lll是用了原子操作（获取和释放锁的所有权）和futex操作（阻塞知道一个锁的状态发生变化）的组合。
一个锁可以是下面三种状态中的一种：
0：没有被获取
1：被获取没有等待者；没有别的线程为了修改锁的状态而阻塞了或者即将阻塞
2：被获取，可能有等待者；可能存在别的线程为了修改锁的状态而阻塞了或者即将阻塞

我们期待通常的case是一个无争的锁，因此我们仅需要在状态0和1之间转换；释放锁不需要唤醒其他阻塞的线程。
如果锁是有争的并且一个线程决定通过一个futex操作进行阻塞，然后这个线程需要首先修改状态到 >1;
如果这个状态在锁释放的过程中被观测到，释放线程将从所有潜在的阻塞的线程中唤醒一个。

代码中会通过一个叫"private"的参数，它可能被设置成 
   LLL_PRIVATE: 锁只在进程内共享
   LLL_SHARED:  锁可能跨进程共享

条件变量包含一个广播方面的优化：在一个锁的futex上等待线程从新入队列，因此这有一个锁的特殊变种——确保总是设置锁状态 >1 而不仅仅是1.

Robust locks 设置锁到持有者的id上。 允许发现哪里发生了持有者退出了但是没有释放锁的情形。
标记和持有者Id做OR运算来记录锁状态的附加信息.
robust locks 的状态是:
  0: 未被获取
 id: 被持有了 (by user identified by id & FUTEX_TID_MASK)

在robust lock的value中可能会被设置下面这连个变量：
   FUTEX_WAITERS     - 可能有等待者
   FUTEX_OWNER_DIED  - 持有者已经退出了但是没有释放futex



